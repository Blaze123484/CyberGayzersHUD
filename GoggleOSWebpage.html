<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
/* Your existing styles here */
.collapsible {
  background-color: #777;
  color: white;
  cursor: pointer;
  padding: 18px;
  width: 50%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

.active, .collapsible:hover {
  background-color: #555;
}

.collapsible:after {
  content: '\002B';
  color: white;
  font-weight: bold;
  float: right;
  margin-left: 5px;
}

.active:after {
  content: "\2212";
}

.content {
  padding: 0 18px;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
  background-color: #f1f1f1;
}
</style>
</head>
<body>

<h2>GoggleOS Webserver</h2>

<button class="collapsible">Connect To Server</button>
<div class="content">
    <input type="text" id="serverIp" style='font-size: 18px;' placeholder="Enter IP address">
    <span id="connectionStatus" style='font-size: 18px; color: red;'>Not Connected</span>
    <br>
    <button id="connectButton" style='font-size: 18px;'>Connect</button>
</div>

<button class="collapsible">Enter New Wifi Credentials</button>
<div class="content">
    <input type="text" id="ssidInput" style='font-size: 18px;' placeholder="SSID" ><br>
    <input type="password" id="passwordInput" style='font-size: 18px;' placeholder="Password"><br>
    <button onclick="submitNetworkCredentials();" style='font-size: 18px;'>Connect</button>
</div>

<button class="collapsible">Submit Message</button>
<div class="content">
    <input type="text" id="wifiMessageInput" style='font-size: 18px;' placeholder="Message"><br>
    <button onclick="submitWifiMessage();" style='font-size: 18px;'>Submit</button>
</div>

<button class="collapsible">Submit New Frame</button>
<div class="content">
    <!-- Replace the text input with an input element of type "file" for image selection -->
    <input type="file" id="imageFileInput" accept="image/jpeg" style='font-size: 18px;'>
    <br>
    <button onclick="submitImage();" style='font-size: 18px;'>Submit</button>
</div>
<button class="collapsible">Screen Capture</button>
<div class="content">
    <br>
    <video autoplay height="480px" hidden></video>
    <br>
    <canvas id="canvas" width="720" height="480"></canvas><br>
    <button id="shareButton" onclick="startCapture();" style='font-size: 18px;'>Share</button>
    <button id="stopShareButton" onclick="stopCapture();" style='font-size: 18px; display: none;'>Stop Sharing</button>
    <label for="intervalTicker">Interval (ms):</label>
    <input type="number" id="intervalTicker" value="2500">
    <!-- Quality ticker for captured JPEG -->
    <label for="qualityTicker">Quality:</label>
    <select id="qualityTicker">
        <option value="1">1</option>
        <option value="0.9">0.9</option>
        <option value="0.8">0.8</option>
        <option value="0.7">0.7</option>
        <option value="0.6">0.6</option>
        <option value="0.5">0.5</option>
        <option value="0.4">0.4</option>
        <option value="0.3">0.3</option>
        <option value="0.2">0.2</option>
        <option value="0.1">0.1</option>
    </select>
    <button id="captureAndSendButton" onclick="captureAndSend();" style='font-size: 18px; display: none;'>Capture & Send</button>
    
    <!-- Toggleable button for auto capture -->
    <button id="autoCaptureToggleButton" onclick="toggleAutoCapture();" style='font-size: 18px;'>Start Auto Capture</button>
</div>

<button class="collapsible">Camera</button>
<div class="content">
    <!--placeholder for future development stuff-->
</div>

<button class="collapsible">Reflash</button>
<div class="content">
    <!--placeholder for future development stuff-->
</div>

<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    } 
  });
}

var connectionStatus = document.getElementById("connectionStatus");

// WebSocket connection handling
document.getElementById("connectButton").addEventListener("click", function() {
  const serverIp = document.getElementById("serverIp").value;
  if (!serverIp) {
    console.error("Please enter the IP address of the ESP32 server.");
    return;
  }

  const websocketAddress = `ws://${serverIp}/ws`;
  websocket = new WebSocket(websocketAddress);
  console.log("attempting websocket connection");
  websocket.onopen = onOpen;
  websocket.onclose = onClose;
  websocket.onmessage = onMessage;
});

function onOpen(event) {
    console.log('Connection opened');
    connectionStatus.textContent = "Connected";
    connectionStatus.style.color = "green";
}

function onClose(event) {
    console.log('Connection closed');
    connectionStatus.textContent = "Not Connected";
    connectionStatus.style.color = "red";
    stopCapture();
    clearInterval(autoCaptureInterval); // Stop the auto capture interval
    document.getElementById("autoCaptureToggleButton").textContent = "Start Auto Capture";
    
  setTimeout(initWebSocket, 2000);
}

function onMessage(event) {
  var state;
  if (event.data == "1"){
    state = "ON";
  } else {
    state = "OFF";
  }
  document.getElementById('state').innerHTML = state;
}

// Consolidated function for submitting image data
async function submitImage() {
  var imageFileInput = document.getElementById("imageFileInput");
  var imageFile = imageFileInput.files[0]; // Get the selected image file

  if (!imageFile) {
    console.log("No image selected.");
    return;
  }

  // Read the selected image file as an ArrayBuffer (raw binary data)
  var reader = new FileReader();

  reader.onloadend = function (e) {
    if (e.target.readyState === FileReader.DONE) {
      var rawImageData = e.target.result;
      websocket.send("START_IMAGE_TRANSMISSION");
      websocket.send(new Uint8Array(rawImageData)); // Send the Uint8Array directly
      websocket.send("END_IMAGE_TRANSMISSION");
    } else {
      console.log("Error reading the file.");
    }
  };

  reader.readAsArrayBuffer(imageFile);
}

var canvas = document.querySelector('#canvas');
var ctx = canvas.getContext('2d');
var video = document.querySelector('video');
var desiredWidth = 720;
var desiredHeight = 480;

var shareButton = document.getElementById("shareButton");
var stopShareButton = document.getElementById("stopShareButton");
var captureAndSendButton = document.getElementById("captureAndSendButton");

async function startCapture() 
{
    video.srcObject = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "always" }, audio: false });
    video.addEventListener('play', function() {
        drawVideoFrame();
    });

    shareButton.style.display = "none";
    stopShareButton.style.display = "block";
    captureAndSendButton.style.display = "block";
}

function stopCapture() 
{
    const stream = video.srcObject;
    const tracks = stream.getTracks();

    tracks.forEach(function(track) {
        track.stop();
    });

    video.srcObject = null;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    shareButton.style.display = "block";
    stopShareButton.style.display = "none";
    captureAndSendButton.style.display = "none";
}

function drawVideoFrame() 
{
    if (video.paused || video.ended) {
        return;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(video, 0, 0, desiredWidth, desiredHeight);
    requestAnimationFrame(drawVideoFrame);
}

async function captureAndSend() {
    const imageData = canvas.toDataURL('image/jpeg', parseFloat(document.getElementById("qualityTicker").value));

    // Convert the image data URL to a Blob and send it as an ArrayBuffer
    fetch(imageData)
        .then(response => response.blob())
        .then(blob => {
            const reader = new FileReader();
            reader.onload = function(event) {
                const arrayBuffer = event.target.result;
                websocket.send("START_IMAGE_TRANSMISSION");
                websocket.send(new Uint8Array(arrayBuffer)); // Send the Uint8Array directly
                websocket.send("END_IMAGE_TRANSMISSION");
            };
            reader.readAsArrayBuffer(blob);
        });
}
var isAutoCaptureActive = false;

function toggleAutoCapture() {
    if (!isAutoCaptureActive) {
        const interval = parseInt(document.getElementById("intervalTicker").value);
        autoCaptureInterval = setInterval(captureAndSend, interval);
        document.getElementById("autoCaptureToggleButton").textContent = "Stop Auto Capture";
    } else {
        clearInterval(autoCaptureInterval); // Stop the auto capture interval
        document.getElementById("autoCaptureToggleButton").textContent = "Start Auto Capture";
    }
    
    isAutoCaptureActive = !isAutoCaptureActive;
}

async function submitNetworkCredentials() {
    var ssidInput = document.getElementById("ssidInput");
    var passwordInput = document.getElementById("passwordInput");
    var data = {
        identifier: "save-credentials",
        ssid: ssidInput.value,
        password: passwordInput.value
    };
    websocket.send(JSON.stringify(data));
}

async function submitWifiMessage() {
    var wifiMessageInput = document.getElementById("wifiMessageInput");
    var data = {
        identifier: "save-wifiMessage",
        WifiMessage: wifiMessageInput.value
    };
    websocket.send(JSON.stringify(data));
}

// ... (rest of the existing JavaScript code) ...

</script>

</body>
</html>
